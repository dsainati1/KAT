open Ast
open Batteries

module Brzozowski = struct
	let rec e : term -> term = function
		  Act _ -> Zero
		| One -> One
		| Zero -> Zero
		| Plus (e1, e2) -> Plus (e e1, e e2) |> simplify
		| Times (e1, e2) -> Times (e e1, e e2) |> simplify
		| Star _ -> One
	and d (exp : term) : string -> term = fun a -> 
		match exp with
		| Zero -> Zero
		| One -> Zero
		| Act b when a = b -> One
		| Act b -> Zero
		| Plus (e1, e2) -> Plus (d e1 a, d e2 a) 
		| Times (e1, e2) -> 
			let e1' = Times (d e1 a, e2) in 
			let e2' = Times (e e1, d e2 a) in
			Plus (e1', e2')
		| Star e' -> Times (d e' a, exp)
end

type id = string

type nfa = id * (n_state list)
and n_state = Final of id * (n_transition list) | NonFinal of id * (n_transition list)
and n_transition = string * (id list)

type dfa = id * (d_state list)
and d_state = Final of id * (d_transition list) | NonFinal of id * (d_transition list)
and d_transition = string * id

(*===================================================================================
								Utility functions									
====================================================================================*)

let get_n_state_id : n_state -> id = function
	  Final (id, _) -> id
	| NonFinal (id, _) -> id

let string_of_nfa ((start, states) : nfa) : string = 
	let add_label (state : n_state) (s : string) : string = 
		let id = get_n_state_id state in 
		s ^ "\"" ^ id ^ "\" [label=\"" ^ id ^ "\"" ^
		(match state with
		  Final _ -> " shape=\"doublecircle\"];\n"
		| NonFinal _ -> " shape=\"circle\"];\n") in 

	let add_transitions (state : n_state) : string -> string = 
		let transitions : n_state -> n_transition list = function
			Final (_, t) -> t | NonFinal  (_, t) -> t in
		let string_of_transition (letter, dest) s = 
			s ^ "\"" ^ get_n_state_id state ^ "\" -> \"" ^ 
			dest ^ "\" [label=\"" ^ letter ^ "\"];\n" in
		transitions state 
		|> List.map (fun (l, ds) -> List.map (fun d -> (l, d)) ds) 
		|> List.flatten
		|> List.fold_right string_of_transition in 

	let add_start_node graph = 
		graph ^ "START [style=invis];\nSTART -> \"" ^ start ^ "\";\n}" in 

    "digraph NFA {\ncompound=true;\nordering=out;\n"
	|> List.fold_right add_label states
	|> List.fold_right add_transitions states
	|> add_start_node


(*===================================================================================
								NFA Construction									
====================================================================================*)

(* Finds all the possible successor states after transitioning from e on s *)
let succs (e : term) (s : string) : term list = 
	(* Plus functions like a nondeterministic choice *)
	let rec choices (e : term) : term list = 
		match e with
		| Plus (e1, e2) -> (choices e1 @ choices e2) |> List.unique
		| _ -> [e] in 
	Brzozowski.d e s |> simplify |> choices

(* Collects all the states in the nfa generated by term e, where each state
   corresponds to a term formed by the Brzozowski derivative of e *)
let rec collect_states (vars : StringSet.t) (acc : term list) (e : term) : term list = 
	let filtered = StringSet.fold (fun s lst -> succs e s @ lst) vars []
	|> List.unique
	|> List.filter (fun state -> List.mem state acc |> not) in
	List.fold_left (collect_states vars) (acc @ filtered) filtered

(* Constructions a non-deterministic transition from a term and the transition string *)
let term_to_n_transition (e : term) (s : string): n_transition = 
	s, succs e s |> List.map term_to_string

(* Constructs a state from a term e by associating it with the transitions out of it.
   The term is marked final or nonfinal based on its Brzozowski derivative *)
let term_to_n_state (vars : StringSet.t) (e : term) : n_state = 
	let transitions = StringSet.elements vars |> List.map (term_to_n_transition e) in 
	let id = term_to_string e in 
	match Brzozowski.e e with
	| One -> Final (id, transitions)
	| Zero -> NonFinal (id, transitions)
	| _ -> failwith "impossible"

(* Builds an nfa that accepts a regular set equivalent to the input term over the 
   alphabet vars*)
let build_nfa (e : term) (vars : StringSet.t) : nfa = 
	   collect_states vars [e] e 
	|> List.map (term_to_n_state vars)
	|> Tuple2.make (term_to_string e) 

(*===================================================================================
								DFA Construction									
====================================================================================*)

let determinize (n : nfa) : dfa = 
	failwith "unimplemented"

(*===================================================================================
								DFA Minimization									
====================================================================================*)

let minimize (d : dfa) : dfa =
	failwith "unimplemented"

(*===================================================================================
								 Bisimulation									
====================================================================================*)

let equal (d1 : dfa) (d2 : dfa) : string option = 
	None